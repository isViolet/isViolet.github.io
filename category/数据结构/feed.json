{
    "version": "https://jsonfeed.org/version/1",
    "title": "友人帐🎴 • All posts by \"数据结构\" category",
    "description": "",
    "home_page_url": "https://isviolet.github.io",
    "items": [
        {
            "id": "https://isviolet.github.io/p/1899f14b.html",
            "url": "https://isviolet.github.io/p/1899f14b.html",
            "title": "栈的概念及其应用",
            "date_published": "2021-05-18T13:04:47.386Z",
            "content_html": "<h2 id=\"栈的概念及其应用\"><a class=\"anchor\" href=\"#栈的概念及其应用\">#</a> 栈的概念及其应用</h2>\n<ul>\n<li>栈是仅限制在表尾进行插入和删除操作的特殊线性表</li>\n<li>栈中限制操作的表尾端称为 “栈顶”，另一端称为 “栈底”</li>\n<li>栈具有后进先出或先进后出的操作特性</li>\n</ul>\n<p>栈的生活应用：抽纸盒，子弹压入和弹出</p>\n<p>栈的计算机的应用：表达式求值，迷宫求解，函数递归</p>\n<h2 id=\"顺序栈基本操作的实现\"><a class=\"anchor\" href=\"#顺序栈基本操作的实现\">#</a> 顺序栈基本操作的实现</h2>\n<p>栈的顺序存储结构描述：</p>\n<pre><code>typedef struct&#123;\n    SElemType *base;//栈底指针\n    SElemType *top;//栈顶指针\n    int stacksize;\n&#125;SqStack;\n</code></pre>\n<h3 id=\"顺序栈入栈操作\"><a class=\"anchor\" href=\"#顺序栈入栈操作\">#</a> <strong>顺序栈入栈操作</strong></h3>\n<p>分析：将元素 e 插入到顺序栈 S 内，将其成为新的栈顶元素。</p>\n<ul>\n<li>入栈步骤</li>\n</ul>\n<ol>\n<li>检测（判断栈是否满）</li>\n</ol>\n<p>如果 S.top-S.base &gt;= S.stacksize, 则需要用 realloc 函数追加空间</p>\n<ol start=\"2\">\n<li>压入（将 e 压入到栈顶指针所指示的存储单元）</li>\n</ol>\n<p>*S.top = e;</p>\n<ol start=\"3\">\n<li>修正栈顶指针（栈顶指针后移一位）</li>\n</ol>\n<p>S.top = S.top+1;</p>\n<ul>\n<li>时间复杂度为 O (1)</li>\n</ul>\n<h3 id=\"顺序栈出栈操作\"><a class=\"anchor\" href=\"#顺序栈出栈操作\">#</a> <strong>顺序栈出栈操作</strong></h3>\n<p>分析：当栈非空时，删除栈顶元素，并返回该元素</p>\n<ul>\n<li>出栈步骤</li>\n</ul>\n<ol>\n<li>检测（判断栈是否满）</li>\n</ol>\n<p>若 S.top S.base，则结束操作</p>\n<ol start=\"2\">\n<li>将栈顶指针前移一位</li>\n</ol>\n<p>S.top = S.top -1;</p>\n<ol start=\"3\">\n<li>读取到被删的栈顶元素并存入 e 中</li>\n</ol>\n<p>e = *S.top;</p>\n<h2 id=\"链栈基本操作的实现\"><a class=\"anchor\" href=\"#链栈基本操作的实现\">#</a> 链栈基本操作的实现</h2>\n<h3 id=\"链栈入栈操作的实现\"><a class=\"anchor\" href=\"#链栈入栈操作的实现\">#</a> <strong>链栈入栈操作的实现</strong></h3>\n<p>分析：将元素 e 插入到链栈中，使其成为新的栈顶元素</p>\n<ol>\n<li>确定插入位置</li>\n</ol>\n<p>插入到 S 指针所指示的结点前面</p>\n<ol start=\"2\">\n<li>产生待插入的新结点</li>\n</ol>\n<p>p = (LinkList)malloc(sizeof(SNode));</p>\n<p>p-&gt;data = e;</p>\n<ol start=\"3\">\n<li>修改链指针（使新结点链入链表的指定位置）</li>\n</ol>\n<p>p-&gt;next = S;</p>\n<p>S = p;</p>\n<h3 id=\"链栈出栈操作的实现\"><a class=\"anchor\" href=\"#链栈出栈操作的实现\">#</a> <strong>链栈出栈操作的实现</strong></h3>\n<p>分析： 当栈非空时，删除栈顶元素，并返回该元素</p>\n<ol>\n<li>判断链栈是否空</li>\n</ol>\n<p>若 S NULL; 则结束操作</p>\n<ol start=\"2\">\n<li>确定待删结点</li>\n</ol>\n<p>p = S;</p>\n<ol start=\"3\">\n<li>修改链指针，使待删结点从链中脱离出来</li>\n</ol>\n<p>S = p-&gt;next;</p>\n<ol start=\"4\">\n<li>释放空间</li>\n</ol>\n<p>e = p-&gt;data;</p>\n<p>free(p);</p>\n",
            "tags": [
                "栈"
            ]
        },
        {
            "id": "https://isviolet.github.io/p/95c1e261.html",
            "url": "https://isviolet.github.io/p/95c1e261.html",
            "title": "线性表的顺序存储及其实现",
            "date_published": "2021-05-18T12:53:09.277Z",
            "content_html": "<h2 id=\"顺序表的插入操作\"><a class=\"anchor\" href=\"#顺序表的插入操作\">#</a> 顺序表的插入操作</h2>\n<p>主要操作步骤及其实现方法：</p>\n<ul>\n<li>检测（判断参数 i 是否合理及空间是否满）\n<ol>\n<li>若 i&lt;1||i&gt;L.length+1，插入位置不合理，算法结束；</li>\n<li>若 L.length&gt;=L.listsize，则存储空间已满，需增加分配空间</li>\n</ol>\n</li>\n<li>后移（插入位置及之后的所有元素后移一位）</li>\n</ul>\n<pre><code>q = &amp;(L.elem[i-1]); //q指示插入位置\nfor(p = &amp;(L.elem[L.length-1]);p&gt;=q;--p)\n\\*(p+1) = *p; //后移一位\n</code></pre>\n<ul>\n<li>插入（将新元素插入到指定位置上）</li>\n</ul>\n<pre><code>*q = e; //插入e\n</code></pre>\n<ul>\n<li>修正表长（表长加 1）</li>\n</ul>\n<pre><code>++L.length; //表长增1\n</code></pre>\n<h2 id=\"顺序表的删除操作\"><a class=\"anchor\" href=\"#顺序表的删除操作\">#</a> 顺序表的删除操作</h2>\n<p>主要操作步骤及其实现：</p>\n<ul>\n<li>检测（判断参数 i 是否合理）若 i&lt;1||i&gt;L.length，删除位置不合理，算法结束</li>\n<li>前移（删除元素之后的所有元素前移一位）</li>\n</ul>\n<pre><code>p = &amp;(L.elem[i-1]); //p指示删除位置\ne = *p; //用e返回被删除元素的值\nq = &amp;(L.elem[L.length-1]); //p指示表尾位置\nfor(p++; p&gt;=q; --p)\n    *(p+1) = *p; //后移一位\n</code></pre>\n<ul>\n<li>修正表长（表长减 1）</li>\n</ul>\n<pre><code>--L.length; //表长减1\n</code></pre>\n",
            "tags": [
                "线性表"
            ]
        },
        {
            "id": "https://isviolet.github.io/p/9913f71d.html",
            "url": "https://isviolet.github.io/p/9913f71d.html",
            "title": "线性表的存储结构",
            "date_published": "2021-05-18T12:52:08.975Z",
            "content_html": "<h2 id=\"线性表的顺序存储结构\"><a class=\"anchor\" href=\"#线性表的顺序存储结构\">#</a> 线性表的顺序存储结构：</h2>\n<p>是用一组地址连续的存储单元依次存放线性表中的数据元素的存储结构。</p>\n<ul>\n<li>下标为 0 的元素是线性表的起始地址，称为线性表的基地址，n 为表的长度，用 a1 表示</li>\n<li>用顺序存储的线性表就称为顺序表</li>\n</ul>\n<h2 id=\"数据元素的地址计算公式\"><a class=\"anchor\" href=\"#数据元素的地址计算公式\">#</a> 数据元素的地址计算公式：</h2>\n<ul>\n<li>LOC(a[i]) = LOC(a[i-1]) + C</li>\n<li>LOC(a[i]) = LOC(a[1]) + (i-1) * C</li>\n</ul>\n<p>解析：</p>\n<ul>\n<li>a [1] 是线性表的基地址</li>\n<li>(i-1) 表示所求元素的下标 (下标从 0 开始)</li>\n<li>C 代表一个数据元素所占的存储量</li>\n</ul>\n<h2 id=\"线性表的顺序存储结构描述\"><a class=\"anchor\" href=\"#线性表的顺序存储结构描述\">#</a> 线性表的顺序存储结构描述：</h2>\n<ul>\n<li>静态顺序存储结构的描述\n<ul>\n<li>当前定义的表的长度固定</li>\n<li>静态顺序表类型名：SqListtp</li>\n</ul>\n</li>\n</ul>\n<p>代码如下：</p>\n<pre><code>#define MAXLEN 80\ntypedef struct &#123;\n    ElemType elem[MAXLEN];\n    int length; //当前表的长度\n&#125; SqListtp;\n</code></pre>\n<ul>\n<li>动态顺序存储结构的描述\n<ul>\n<li>元素类型是存储空间的基址</li>\n<li>有预分配的空间容量</li>\n</ul>\n</li>\n</ul>\n<p>代码如下：</p>\n<pre><code>typedef struct &#123;\n    ElemType *elem; //存储空间的基址\n    int length; //当前表的长度\n    int listsize;//当前预分配的空间容量\n&#125; SqList;\n</code></pre>\n<ul>\n<li>重要组成要素\n<ol>\n<li>顺序表 L 的基地址：L.elem</li>\n<li>顺序表 L 的长度：L.length</li>\n<li>顺序表 L 的容量：L.listsize</li>\n<li>数据元素 a [i]：L.elem [i-1]</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"线性表的链式存储结构\"><a class=\"anchor\" href=\"#线性表的链式存储结构\">#</a> 线性表的链式存储结构：</h2>\n<ul>\n<li>链式存储中每个节点只含一个指针域，则称为单链表或线性链表</li>\n<li>链式存储中每个节点含多个指针域，则称为多链表\n<ul>\n<li>单链表的存储结构描述：</li>\n</ul>\n</li>\n</ul>\n<p>一个结点：data（数据域），next（指针域）</p>\n<pre><code>typedef struct LNode &#123;\n    ElemType data; //数据域\n    struct LNode *next; //指针域\n&#125;LNode,*LinkList;\n</code></pre>\n<h2 id=\"顺序存储结构的特点\"><a class=\"anchor\" href=\"#顺序存储结构的特点\">#</a> 顺序存储结构的特点：</h2>\n<ul>\n<li>优势\n<ol>\n<li>存储密度高；</li>\n<li>便于随机存储；</li>\n</ol>\n</li>\n<li>劣势\n<ol>\n<li>不便于插入、删除。（会造成大量数据移动）</li>\n<li>需预分配空间充足，造成空间浪费</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"链式存储结构的特点\"><a class=\"anchor\" href=\"#链式存储结构的特点\">#</a> 链式存储结构的特点：</h2>\n<ul>\n<li>优势\n<ol>\n<li>便于插入、删除操作</li>\n<li>能有效利用存储空间</li>\n</ol>\n</li>\n<li>劣势不能随机存取数据元素，只能顺序存取数据元素</li>\n</ul>\n",
            "tags": [
                "线性表"
            ]
        },
        {
            "id": "https://isviolet.github.io/p/6f136d02.html",
            "url": "https://isviolet.github.io/p/6f136d02.html",
            "title": "线性表相关概念",
            "date_published": "2021-05-18T12:51:00.026Z",
            "content_html": "<h2 id=\"线性表的定义\"><a class=\"anchor\" href=\"#线性表的定义\">#</a> 线性表的定义：</h2>\n<p>线性表是由 n (n&gt;=0) 个数据元素（结点）所构成的有限序列。</p>\n<ul>\n<li>第一个元素：开始结点 a1</li>\n<li>最后一个元素：终端结点 an</li>\n<li>数据元素：（a1，a2，a3，…，an），当 n 为 0 时，称为空表</li>\n<li>a (i-1) 是 ai 的直接前趋，a (i+1) 是 ai 的直接后趋</li>\n</ul>\n<h2 id=\"线性表的结构逻辑结构特点\"><a class=\"anchor\" href=\"#线性表的结构逻辑结构特点\">#</a> 线性表的结构（逻辑结构）特点：</h2>\n<ol>\n<li>它由 n (n&gt;=0) 个同类型的元素组成；</li>\n<li>有且仅有一个开始结点 (第一个元素) 和终端结点 (最后 - 个元素) ;</li>\n<li>每个元素除开始结点和终端结点之外，有且仅有一个前驱和一个后继。</li>\n</ol>\n<h2 id=\"线性表的抽象数据类型定义\"><a class=\"anchor\" href=\"#线性表的抽象数据类型定义\">#</a> 线性表的抽象数据类型定义：</h2>\n<ul>\n<li>数据对象 (D)：D= 元素集合；</li>\n<li>数据关系 (S)：R= 相邻关系</li>\n<li>基本操作 (P)：\n<ol>\n<li>初始化操作：initList (&amp;L)</li>\n<li>结构销毁操作：destroyList (&amp;L)</li>\n<li>线性表判空操：listEmpty (L)</li>\n<li>求线性表的长度操作：listLength (L)</li>\n<li>求数据元素的前驱操作：priorElem (L, cur_e, &amp;pre_e);</li>\n<li>求数据元素的后继操作：NextElem (L, cur_e, &amp;next_e)</li>\n<li>取线性表中某个数据元素操作：GetElem (L, i, &amp;e)</li>\n<li>定位 (查找) 操作：LocateElem (L, e, compare ())</li>\n<li>遍历线性表操作：ListTraverse (L, visit ())</li>\n<li>线性表置空操作：ClearList (&amp;L)</li>\n<li>插入操作：ListInsert (&amp;L, i, e)</li>\n<li>删除操作：ListDelete (&amp;L, i, &amp;e)</li>\n</ol>\n</li>\n</ul>\n",
            "tags": [
                "线性表"
            ]
        }
    ]
}